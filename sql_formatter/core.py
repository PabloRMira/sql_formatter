# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['assert_and_print', 'MAIN_STATEMENTS', 'remove_newlines_mspaces', 'preformat_statement', 'lowercase_query',
           'add_whitespaces_between_symbols', 'format_select', 'format_from', 'format_join', 'format_on',
           'format_where', 'format_statement_line', 'format_statements', 'add_ending_semicolon', 'format_simple_sql',
           'extract_outer_subquery', 'format_subquery', 'format_sql']

# Cell
import re

# Cell
def assert_and_print(s_in, s_expected):
    "Assert equality of `s_in` and `s_expected` and print the result of `s_in` if the assertion worked"
    try:
        assert s_in == s_expected
    except:
        print("Assertion failed\n")
        print("Input:\n")
        print(s_in)
        print("\n")
        print("Expected:\n")
        print(s_expected)
        assert s_in == s_expected
    print(s_in)
    return None

# Cell
MAIN_STATEMENTS = [
    "create table",
    "create or replace table",
    "create view",
    "create or replace view",
    "select",
    "from",
    "left join",
    "inner join",
    "outer join",
    "right join",
    "on",
    "where",
    "group by"
]

# Cell
def remove_newlines_mspaces(s):
    """Remove newline and too many spaces characters.
    Newline characters in SELECT statement with comments
    are replaced by special token [EOC] (end of comment)
    because otherwise we cannot format SELECT statements
    with comments properly
    """
    s = s.strip()  # strip sentence
    s = re.sub(r"[\r\t\f\v ]{2,}", " ", s)  # remove too many whitespaces but not newlines
    s = re.sub(r"\n[\r\t\f\v ]+", r"\n", s)  # remove whitespaces after newline
    s = re.sub(r"[\r\t\f\v ]+\n", r"\n", s)  # remove whitespaces before newline
    split_s = re.split(r"(select .*?)(from)", s, flags=re.I | re.DOTALL)  # split to get individual select lines
    # add special token [EOC] = End of comment for -- comments
    split_s = [
        re.sub(r"(--.*?)(\n)", r"\1[EOC]", line)  # add special token for end of comment in select lines
        for line in split_s
    ]
    # add special token [EOC] = End of comment for /*  */ comments
    split_s = [
        re.sub(r"(\/\*.*\*\/)", r"\1[EOC]", line)  # add special token for select lines
        for line in split_s
    ]
    s = "".join(split_s)  # join all the lines
    s = re.sub("\n", " ", s)  # remove newlines
    s = re.sub(r"\[EOC\][\r\t\f\v ]+", "[EOC]", s)  # remove whitespaces after [EOC]
    s = re.sub(r"[\r\t\f\v ]+\[EOC\]", "[EOC]", s)  # remove whitespaces before [EOC]
    return s

# Cell
def preformat_statement(s, statements):
    """Write a newline in `s` for all `statements` and
    uppercase them but not if they are inside a comment"""
    s = remove_newlines_mspaces(s)  # mark end of comments
    split_s = s.split("[EOC]")  # split by end of comments
    split_out = []  # output split
    for line in split_s:  # loop over lines
        split_c = re.split("((?:--.*|\/\*.*\*\/))", line)  # split by comment / no comment
        split_rec = split_c  # recursive list
        for statement in statements:  # loop over statements
            if re.match("^create", statement, flags=re.I):
                split_rec = [  # update list
                    re.sub(rf"\s*({statement})\b(.*) as\b", "\n" + statement.upper() + r"\2 AS", line, flags=re.I)
                    if not re.search("(?:--.*|\/\*.*\*\/)", line)
                    else line
                    for line in split_rec
                ]
            else:
                split_rec = [  # update list
                    re.sub(rf"\s*({statement})\b", "\n" + statement.upper(), line, flags=re.I)
                    if not re.search("(?:--.*|\/\*.*\*\/)", line)
                    else line
                    for line in split_rec
                ]
        split_out.append("".join(split_rec))  # update list
    s = "[EOC]".join(split_out)  # join everything together
    return s

# Cell
def lowercase_query(s):
    "Lowercase query but let comments untouched"
    split_s = s.split("\n")  # split by newline
    split_s = [
        line if re.match(r"^--", line) # comment at the beginning
        else re.sub(r"(.*)(--.*)$", lambda pat: pat.group(1).lower() + pat.group(2), line)
        if re.match(r".*--", line) # comment in between
        else re.sub(r"(.*)(\/\*.*\*\/)(.*)$",
                    lambda pat: pat.group(1).lower() + pat.group(2) + pat.group(3).lower(), line)
        if re.match(r".*\/\*.*\*\/.*", line) # comment in between
        else line.lower()  # no comment
        for line in split_s
    ]
    s = "\n".join(split_s)
    return s

# Cell
def add_whitespaces_between_symbols(s):
    "Add whitespaces between symbols in line `s`"
    s = re.sub(r"([^\s=!<>])([=!<>]+)", r"\1 \2", s, flags=re.I)  # no space left
    s = re.sub(r"([=!<>]+)([^\s=!<>])", r"\1 \2", s, flags=re.I)  # no space right
    s = re.sub(r"([^\s=!<>])([=!<>]+)([^\s=!<>])", r"\1 \2 \3", s, flags=re.I)  # no space left and right
    return s

# Cell
def format_select(s):
    "Format SELECT statement line `s`"
    # remove [EOC] at end of SELECT
    if re.search(r"\[EOC\]$", s):
        s = re.sub(r"\[EOC\]$", "", s)
    # if comma is found at the end of select statement then remove comma
    if re.search(r"[\w\d]+,\s*$", s, flags=re.I):
        s = re.sub(r"([\w\d]+)(,+)(\s*)$", r"\1", s, flags=re.I)
    elif re.search(r"[\w\d]+,\s*--[\w\d\s]*$", s, flags=re.I):
        s = re.sub(r"([\w\d]+)(,+)(\s*)(--.*)$", r"\1 \4", s, flags=re.I)
    elif re.search(r"[\w\d]+,\s*\/\*.*\*\/$", s, flags=re.I):
        s = re.sub(r"([\w\d]+)(,+)(\s*)(\/\*.*\*\/)$", r"\1 \4", s, flags=re.I)
    s = add_whitespaces_between_symbols(s)  # add whitespaces between symbols
    s = re.sub(r"(,)(\s*)([\w\d]+)", r"\1\n       \3", s)  # add newline after each comma (no comments) and indentation
    s = re.sub(r"\[EOC\]", "\n       ", s)  # replace [EOC] by newline
    s = re.sub(r"(then.*?) ((?:when|else).*?)", r"\1\n\2", s)  # add newline before when or else
    split_s = s.split("\n")
    split_s = [
        line if not re.match("^(?:when|else)", line.strip())
        else " " * 12 + line.strip()
        for line in split_s
    ]
    s = "\n".join(split_s)
    s = s.strip()
    return s

# Cell
def format_from(s):
    "Format FROM statement line `s`"
    s = re.sub(  # add indentation
        r"(from )(.*)",
        r"\1  \2",
        s,
        flags=re.I
    )
    return s

# Cell
def format_join(s):
    "Format JOIN statement line `s`"
    s = "    " + s  # add indentation
    return s

# Cell
def format_on(s):
    "Format ON statement line `s`"
    s = add_whitespaces_between_symbols(s)  # add whitespaces between symbols in join
    s = "        " + s  # add indentation
    return s

# Cell
def format_where(s):
    "Format WHERE statement line `s`"
    s = add_whitespaces_between_symbols(s)  # add whitespaces between symbols
    s = s.replace("[EOC]", " ")
    s = re.sub(r"(where )", r"\1 ", s, flags=re.I)  # add indentation afer WHERE
    s = re.sub(r"\sand", r"\n   and", s, flags=re.I)  # add new line before every 'and' and indentation
    s = re.sub(r"\sor", r"\n    or", s, flags=re.I)  # add new line before every 'or' and indentation
    return s

# Cell
def format_statement_line(s):
    "Format statement line `s`"
    statement_funcs = {
        "select": format_select,
        "from": format_from,
        "left join": format_join,
        "right join": format_join,
        "inner join": format_join,
        "outer join": format_join,
        "on": format_on,
        "where": format_where
    }
    for key, format_func in statement_funcs.items():
        if re.match(key, s, flags=re.I):
            s = format_func(s)
    return s

# Cell
def format_statements(s):
    "Format statements lines `s`"
    statement_lines = s.split("\n")
    formatted_lines = [
        format_statement_line(line) for line in statement_lines
    ]
    formatted_s = "\n".join(formatted_lines)
    return formatted_s

# Cell
def add_ending_semicolon(s):
    "Add ending semicolon for SQL query `s`"
    s = s.strip()
    if re.match(r".*[^;]$", s, flags=re.DOTALL):
        s = s + ";"
    return s

# Cell
def format_simple_sql(s, add_semicolon=True):
    """Format a simple SQL query without subqueries `s`.
    If `add_semicolon` is True, then add a semicolon at the end
    """
    s = lowercase_query(s)  # everything lowercased but not the comments
    s = preformat_statement(s, MAIN_STATEMENTS)  # add breaklines for and uppercase the main statements
    s = format_statements(s)  # format statements
    s = re.sub(r"\[EOC\]", "", s)  # replace remaining [EOC]
    if add_semicolon:
        s = add_ending_semicolon(s)  # add ending semicolon if not there yet
    return s

# Cell
def extract_outer_subquery(s):
    "Extract outer subquery in query `s`"
    # initialize container for subquery positions
    # in string `s`
    subquery_pos = []
    # auxiliar indicator to get the subquery right
    ind = True
    # counter for parenthesis
    k = 0
    # loop over string characters
    for i, c in enumerate(s):
        if s[i:(i+8)] == "(\nSELECT" and ind: # query start
            subquery_pos.append(i)
            k = 0  # set the parenthesis counter to 0
            # turn off the indicator for the program to know
            # that we already hit the subquery start
            ind = False
        elif c == "(": # if there is a parenthesis not involving a subquery
            k += 1
        elif c == ")" and k == 0 and not ind: # end position for subquery
            subquery_pos.append(i)
            return subquery_pos
        elif c == ")":
            k -= 1

# Cell
def format_subquery(s, previous_s):
    "Format subquery in line `s` based on indentation on `previous_s`"
    s = re.sub(r"^\(\nSELECT", "(SELECT", s)  # remove newline between parenthesis and SELECT
    # get reference line for the indentation level
    # and remove whitespaces from the left
    ref_line = previous_s.split("\n")[-1].lstrip()
    # if the line contains a JOIN statement then indent with
    # 4 whitespaces
    if re.match(r"\w+ join", ref_line, flags=re.I):
        ref_line = "    " + ref_line
    indentation = len(ref_line) + 1  # get indentation level
    split_s = s.split("\n")  # get lines in subquery
    indented_s = [
        " " * indentation + line  # indent all lines the same
        if not re.match(r"SELECT", line)
        else line
        for line in split_s[1:]
    ]
    # SELECT line + indented lines afterwards
    formatted_split = [split_s[0]] + indented_s
    # concatenate with newline character
    formatted_s = "\n".join(formatted_split)
    return formatted_s

# Cell
def format_sql(s, add_semicolon=True):
    "Format SQL query with subqueries. If `add_semicolon` is True then add a semicolon at the end"
    s = format_simple_sql(s, add_semicolon)  # basic query formatting
    # get first outer subquery positions
    subquery_pos = extract_outer_subquery(s)
    # loop over subqueries
    while subquery_pos is not None:
        # get split
        split_s = [
            s[0:subquery_pos[0]],
            s[subquery_pos[0]:(subquery_pos[1]+1)],
            s[(subquery_pos[1]+1):]
        ]
        # format subquery (= split_s[1])
        split_s[1] = format_subquery(split_s[1], split_s[0])
        # join main part and subquery
        s = "".join(split_s)
        # get first outer subquery positions
        subquery_pos = extract_outer_subquery(s)
    # remove whitespace between word and parenthesis
    s = re.sub(r"\s\)", ")", s)
    return s